# -*- coding: utf-8 -*-
"""Trabajo final python 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LZfKSrAsB6lm44sa_jgScJDZGtj4iU6F

##Data de maratón

<p>Arreglo de la data, es decir relleno con 0s y convierto de únicos datos cualitativos a únicos datos cuantitativos.</p>
"""

import pandas as pd

datos_maraton=pd.read_csv('https://raw.githubusercontent.com/Jacksonpardo/datos/main/MarathonData.csv')
#display(datos_maraton)
datos_maraton['Wall21'] = pd.to_numeric(datos_maraton['Wall21'],errors='coerce')

#Elimino las columnas innecesarias
datos_maraton = datos_maraton.drop(columns=['Name'])
datos_maraton = datos_maraton.drop(columns=['id'])
datos_maraton = datos_maraton.drop(columns=['Marathon'])
datos_maraton = datos_maraton.drop(columns=['CATEGORY'])

#Relleno con 0s los espacios en blancoy elimino los que no
datos_maraton["CrossTraining"] = datos_maraton["CrossTraining"].fillna(0)
#datos_maraton = datos_maraton.dropna(how='any')

datos_maraton["Category"] = datos_maraton["Category"].fillna(0)
#datos_maraton = datos_maraton.dropna(how='any')

datos_maraton["Wall21"] = datos_maraton["Wall21"].fillna(0)
#datos_maraton = datos_maraton.dropna(how='any')

#Doy valores a únicos datos
valores_cross = {"CrossTraining":  {'ciclista 1h':1, 'ciclista 3h':2, 'ciclista 4h':3, 'ciclista 5h':4, 'ciclista 13h':5}}
datos_maraton.replace(valores_cross, inplace=True)

valores_categoria = {"Category":  {'MAM':1, 'M45':2, 'M40':3, 'M50':4, 'M55':5,'WAM':6}}
datos_maraton.replace(valores_categoria, inplace=True)
display(datos_maraton.head(87))

"""##Gráficas

####Comparando 2 variabales
"""

import matplotlib.pyplot as plt
plt.scatter(x = datos_maraton['km4week'], y=datos_maraton['MarathonTime'])
plt.title('km4week Vs Marathon Time')
plt.xlabel('km4week')
plt.ylabel('Marathon Time')
plt.show()

plt.scatter(x = datos_maraton['Wall21'], y=datos_maraton['MarathonTime'])
plt.title('Wall21 Vs Marathon Time')
plt.xlabel('Wall21')
plt.ylabel('Marathon Time')
plt.show()

"""####De dispersión"""

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np


px.scatter(x= list(datos_maraton['km4week']), y = list(datos_maraton['MarathonTime']), color_discrete_sequence  = ['rgb(255,0,0)'])

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np


fig=px.scatter(datos_maraton,x='Category',y='MarathonTime',color='Wall21', size='km4week')
fig.show()

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np

fig2=px.scatter(datos_maraton,x='Category',y='MarathonTime',symbol='sp4week')
fig2.update_traces(marker_size=10) #Cambiar el tamaño del marcador
fig2.show()

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np

fig3=px.scatter(datos_maraton,x='Category',y='MarathonTime',color='sp4week',facet_col='CrossTraining')
fig3.show()

#facet_col (Usado para ver en columnas)
#facet_roe (Usado para ver en filas)

"""##Estadísticas"""

datos_maraton.describe()

datos_maraton.hist()

import plotly.figure_factory as ff

time_arr_list=[np.array(datos_maraton['MarathonTime'])]
group_labels=['Tiempos de maratón']
fig9=ff.create_distplot(time_arr_list,group_labels,bin_size=0.15) #bin_size me va a determinar el tamaño de la distribución de los datos
fig9.show()

fig8=px.histogram(datos_maraton,x='MarathonTime',nbins=16)
fig8.show()

import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np

fig11 =px.scatter(datos_maraton,x='MarathonTime',y='Wall21',trendline='lowess')
fig11.show()

"""##Modelos

###Random Forest Regressor
"""

##RANDOM FOREST REGRESSOR

from sklearn import datasets #Me devolverá valores de X features y "y" target para el dataset que importaré. NO me devuelve un df.
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split as tts
from sklearn.ensemble import RandomForestRegressor as RFR
from sklearn.metrics import r2_score,mean_squared_error

Category=np.array(datos_maraton['Category'])	
km4week=np.array(datos_maraton['km4week'])
sp4week=np.array(datos_maraton['sp4week'])
CrossTraining=np.array(datos_maraton['CrossTraining'])
Wall21=np.array(datos_maraton['Wall21'])
X=np.c_[Category,km4week,sp4week,CrossTraining,Wall21]
#print(x)
y=np.array(datos_maraton['MarathonTime'])
print(np.shape(X))
print(np.shape(y))

Xtrain,Xtest,ytrain,ytest=tts(X,y)
modelRF = RFR(random_state=42)
modelRF.fit(Xtrain,ytrain)
##Verificamos los resultados
ypred= modelRF.predict(Xtest)
r2RF=r2_score(ytest,ypred)
print('R2 de validación')
print(r2RF) #Validación
 ## Como evalúo si existe subajuste o sobreajuste
 ## Comparar los resultados de entrenamiento y los de prueba
#Existe subajuste cuando mi r2 estrá entre [0-0.5]
ypredtrain= modelRF.predict(Xtrain)
r2RT=r2_score(ytrain,ypredtrain)
print('R2 de entrenamiento: ')
print(r2RT) #Entrenamiento

##PROBANDO EL MODELO
print('Podrías intentar con 1-400-20-0-1.4')
aaa=input('Ingresa valor para Category:' )
bbb=input('Ingresa valor para km4week:')
ccc=input('Ingresa valor para sp4week:')
ddd=input('Ingresa valor para CrossTraining:')
eee=input('Ingresa valor para Wall21:')
novo_dato = pd.DataFrame(np.array([[aaa,bbb,ccc,ddd,eee]]),columns=['Category', 'km4week','sp4week', 'CrossTraining','Wall21'])
display(novo_dato)
print('La predicción es: ')
modelRF.predict(novo_dato)

"""###Knieghbors Regressor"""

###KNEIGHBORS REGRESSOR


from sklearn.neighbors import KNeighborsRegressor as KNr
import plotly.graph_objects as go
import numpy as np
import pandas as pd
from sklearn.metrics import r2_score,mean_squared_error
from sklearn.model_selection import train_test_split as tts
from pandas.core.common import random_state
from sklearn import neighbors

Category=np.array(datos_maraton['Category'])	
km4week=np.array(datos_maraton['km4week'])
sp4week=np.array(datos_maraton['sp4week'])
CrossTraining=np.array(datos_maraton['CrossTraining'])
Wall21=np.array(datos_maraton['Wall21'])
X=np.c_[Category,km4week,sp4week,CrossTraining,Wall21]
y=np.array(datos_maraton['MarathonTime'])
print(np.shape(X))
print(np.shape(y))

Xtrain,Xtest,ytrain,ytest=tts(X,y,test_size=0.2,random_state=42)
modelknnr=KNr(n_neighbors=1) #KNeighborsRegressor(n_neighbors=1)
modelknnr.fit(Xtrain,ytrain)

print('Valor máximo: ')
print(np.max(X))
print('Valor mínimo: ')
print(np.min(X))
ypredtrain=modelknnr.predict(Xtrain)
ypredtest=modelknnr.predict(Xtest)
r2modelknntrain=r2_score(ytrain,ypredtrain)
r2modelknntest=r2_score(ytest,ypredtest)
print('Error de entrenamiento')
print(r2modelknntrain)
print('Error de validación')
print(r2modelknntest)

Xr=np.linspace(90,1000,70) #Con este realizaremos el gráfico de dispersión
Xr=np.reshape(Xr,(70,1))
"""
Xtrainr = np.reshape(Xtrain,(345,))
ytrainr = np.reshape(ytrain,(69,))
yr =modelknnr.predict(X)
Xrr = np.reshape(Xr,(70,))
yrr = np.reshape(yr,(87,))
Xtestr = np.reshape(Xtest,(90,))
ytestr = np.reshape(ytest,(18,))

#Dibujo
print('Gráfica')
fig1=go.Figure()
fig1.add_trace(go.Scatter(x=Xtrainr,y = ytrainr, mode ='markers',marker_color = 'red'))
fig1.add_trace(go.Scatter(x=Xrr,y = yrr))
fig1.add_trace(go.Scatter(x = Xtestr, y= ytestr, mode = 'markers', marker_color = 'blue'))
fig1.show()
"""

###PROBANDO EL MODELO
print('Podrías intentar con 1-400-20-0-1.4')
a=input('Ingresa valor para Category:' )
b=input('Ingresa valor para km4week:')
c=input('Ingresa valor para sp4week:')
d=input('Ingresa valor para CrossTraining:')
e=input('Ingresa valor para Wall21:')
new_dato = pd.DataFrame(np.array([[a,b,c,d,e]]),columns=['Category', 'km4week','sp4week', 'CrossTraining','Wall21'])
display(new_dato)
print('La predicción es:')
modelknnr.predict(new_dato)

"""###Ridge vs Lasso"""

###RIDGE VS LASSO



from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.linear_model import LinearRegression
Category=np.array(datos_maraton['Category'])	
km4week=np.array(datos_maraton['km4week'])
sp4week=np.array(datos_maraton['sp4week'])
CrossTraining=np.array(datos_maraton['CrossTraining'])
Wall21=np.array(datos_maraton['Wall21'])
Xla=np.c_[Category,km4week,sp4week,CrossTraining,Wall21]

yla=np.array(datos_maraton['MarathonTime'])
print(np.shape(X))
print(np.shape(y))
yla=np.reshape(yla,(87,1))

Xlatrain, Xlatest, ylatrain, ylatest=tts(Xla, yla,test_size=0.20,random_state=42)
modelRidge=Ridge(alpha=1)
modelLasso=Lasso(alpha=1)
modelLinear=LinearRegression()
r2listt=[]
r2listpr=[]
for i in [modelRidge,modelLasso]:
  i.fit(Xlatrain, ylatrain)
  ytrainp=i.predict(Xlatrain)
  ytestp=i.predict(Xlatest)
  r2t=r2_score(ylatrain,ytrainp) #Score Ridge
  r2listt.append(r2t)
  r2test=r2_score(ytest,ytestp) #Score Lasso
  r2listpr.append(r2test)
print('Score Ridge: ')
print(r2listt)
print('Score Lasso: ')
print(r2listpr)

###PROBANDO EL MODELO
print('Podrías intentar con 1-400-20-0-1.4')
aa=input('Ingresa valor para Category:' )
bb=input('Ingresa valor para km4week:')
cc=input('Ingresa valor para sp4week:')
dd=input('Ingresa valor para CrossTraining:')
ee=input('Ingresa valor para Wall21:')
new_date = pd.DataFrame(np.array([[aa,bb,cc,dd,ee]]),columns=['Category', 'km4week','sp4week', 'CrossTraining','Wall21'])
display(new_date)
print('Las predicciones son:')
print(modelLasso.predict(new_date))
print(modelRidge.predict(new_date))

"""##Análisis con PCA"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler

X = np.array(datos_maraton)
#Todos los valores de la primera fila
print(X[0,:])

##Matriz de dispersión de los datos
#Se necesita un df para poder lograrlo

X_df=datos_maraton
pd.plotting.scatter_matrix(X_df,figsize=(30,30),diagonal='kde')
plt.show()

#Escalamiento de datos

escalador=MinMaxScaler()
escalador.fit(X)
X_escalado=escalador.fit_transform(X)


#Visualizar el x escalado la primera fila
print(X_escalado[0,:])

X_featuresdf=datos_maraton
X_featuresarray=np.array(X_featuresdf)

X_feat_price=X_featuresdf['MarathonTime']
X_feat_gen_array = np.array(X_feat_price)

### Encoding => Variables de texto
from sklearn.preprocessing import LabelEncoder
Encoder = LabelEncoder()
Encoder.fit(X_feat_gen_array)
x_gen_encoder = Encoder.fit_transform(X_feat_gen_array)
print(x_gen_encoder)

## Eliminar el X_gen e ingresamos el xgencodificado

X_singen = X_featuresdf.drop(columns = ['MarathonTime'])
X_singen['TiempoEscalado'] = x_gen_encoder
print(X_singen.head())


#Escalar los datos
from sklearn.preprocessing import MinMaxScaler as MMS
scaler=MMS()
Xgenerado=np.array(X_singen)
X_scal=scaler.fit_transform(Xgenerado)
#print(X_scal)

##Aplicar K-means
#Codo de jambu => Visualizar el mejor K
from sklearn.cluster import KMeans
inercia=[]
for i in range(1,11):
  k_means=KMeans(n_clusters=i)
  k_means.fit(X_scal)
  inercia.append(k_means.inertia_)
#Visualizar el codo de Jambu

plt.plot(range(1,11),inercia)
plt.show()

##K=4
k_means2=KMeans(n_clusters=4)
k_means2.fit(X_scal)
labels=k_means2.labels_
print(labels)


#Calculamos la forma
np.shape(labels)

#Para graficar, primero PCA
from sklearn.decomposition import PCA

pca3=PCA(n_components=2)
pca3.fit(X_scal)
Xpca=pca3.fit_transform(X_scal)

print(np.shape(Xpca))
print(np.shape(labels))

#Para graficar 

plt.scatter(Xpca[:,0],Xpca[:,1],c=labels)
plt.show()